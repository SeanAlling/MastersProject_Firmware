/***************************************************************************************************
Name            : eink_display.cpp
Author          : Sean Alling
Version         : V0.1
Creation Date   : 12/11/2018
Revision History: 
      DATE         BY                     DESCRIPTION
  -----------  ---------  -----------------------------------------------------
  12/11/2018   Sean       Creation
***************************************************************************************************/

/***************************************************************************************************
                                   Header File For This Source File
***************************************************************************************************/
#include "eink_display.h"
/***************************************************************************************************
                                        System Header File
***************************************************************************************************/
#include <stdint.h>
#include <string.h>
/***************************************************************************************************
                                     User Defined Header Files
***************************************************************************************************/

#include "LUTs_for_CFAP152152A00154.h"

#include "BSP_SPI.h"
#include "BSP_GPO.h"
#include "BSP_GPI.h"
#include "BSP_Timer.h"

extern uint8_t emwinFrameBuffer[];
extern const  uint32_t pannel_width ;
extern const  uint32_t pannel_height;

/******************************************//*Private*//********************************************
                            Typedef, Struct, Class, Union, & Enum Definitions
***************************************************************************************************/



/******************************************//*Private*//********************************************
                                    Static Function Prototypes
***************************************************************************************************/


/******************************************//*Private*//********************************************
                                    Constants & Macros Definitions
***************************************************************************************************/


// Default is to point to null.
static SPI_API * spiAPI = 0;
static GPO_API * gpoAPI = 0;
static GPI_API * gpiAPI = 0;
static GPO_Peripheral gpoCS   = 0;
static GPO_Peripheral gpoDC   = 0;
static GPO_Peripheral gpoReset = 0;
static GPI_Peripheral gpiBusy = 0;


#if (SMALL_SCREEN==1)
const uint8_t Power_Setting_PWR_On[]  =
   {0x01,0x03,0x00,0x0A,0x00,0x03};
const uint8_t Booster_Soft_Start_BTST[]  =
   {0x06,0x17,0x17,0x17};
const uint8_t Power_ON_PON[]  =
   {0x04};
const uint8_t Panel_Setting_PSR[]  =
   {0x00,0x83};
  // 1000 0011 = Crystalfontz
  // RREB ULDR
  // |||| ||||-- RST_N *1 = run, 0 for software reset
  // |||| |||--- SHD_N *1 = Booster on, 0 = Booster off
  // |||| ||---- SHL   *1 = scan right, 0 = scan left
  // |||| |----- UD     1 = scan up, *0 = scan down
  // ||||------- BWR    0 = Black/White/Red (Runs LU1 & LU2)
  // |||               *1 = Black/White (Runs LU1 only)
  // |||-------- REG_EN 1 = LUT from register, *0 = LUT from OTP
  // ||--------- RES1:RES0 (over-ridden by 0x61)
  //                 00 = 96x230
  //                 01 = 96x252
  //                *10 = 128x296
  //                 11 = 160x296
const uint8_t Vcom_and_data_interval_setting_CDI[]  =
  {0x50,0x87};
  // 1000 0111 = Crystalfontz
  // BBRB CCCC
  // |||| ||||-- CDI: 0011 = default
  // ||||------- DDX[0]: Black Data Polarity 1=ink, 0=white
  // |||-------- DDX[1]: Red Data Polarity   1=ink, 0=white
  // ||--------- VBD: Border Data Selection
  //             (by experiment for DDX = 00)
  //               00=really light grey
  //               01=muddy red
  //               10=white <<<<
  //               11=black

const uint8_t PLL_control_PLL[]  =
  {0x30,0x29};
const uint8_t Resolution_setting_TRES[]  =
  {0x61,152,152>>8,152&0xFF};
const uint8_t VCM_DC_Setting_VDCS_On[]  =
  {0x82,0x0A};

const uint8_t Vcom_and_data_interval_setting_CDI_Off[]  =
   {0x50,0x17};
const uint8_t VCM_DC_Setting_VDCS_Off[]  =
   {0x82,0x00};
const uint8_t Power_Setting_PWR_Off[]  =
   {0x01,0x00,0x00,0x00,0x00,0x00};
const uint8_t Power_OFF_POF[]  =
   {0x02};
const uint8_t Deep_sleep_DSLP[]  =
   {0x07,0xA5};




#else
const uint8_t Power_Setting_PWR_On[]  =
   {0x01,0x03,0x00,0x2B,0x2B};
const uint8_t Booster_Soft_Start_BTST[]  =
   {0x06,0x17,0x17,0x17};
const uint8_t Power_ON_PON[]  =
   {0x04};
const uint8_t Panel_Setting_PSR[]  =
   {0x00,0x93};

const uint8_t Vcom_and_data_interval_setting_CDI[]  =
  {0x50,0x07};


const uint8_t PLL_control_PLL[]  =
  {0x30,0x3a};
const uint8_t Resolution_setting_TRES[]  =
  {0x61,0x01, 0x90,0x01,0x2c};
const uint8_t VCM_DC_Setting_VDCS_On[]  =
  {0x82,0x0A};

const uint8_t Vcom_and_data_interval_setting_CDI_Off[]  =
   {0x50,0x17};
const uint8_t VCM_DC_Setting_VDCS_Off[]  =
   {0x82,0x12};
const uint8_t Power_Setting_PWR_Off[]  =
   {0x01,0x00,0x00,0x00,0x00,0x00};

const uint8_t Power_OFF_POF[]  =
   {0x02, 0x03, 0x00};
const uint8_t Deep_sleep_DSLP[]  =
   {0x07,0xA5};
#endif
/******************************************//*Private*//********************************************
                                    Private Variable Instantiations
***************************************************************************************************/



/******************************************//*Global*//*********************************************
                                    Global Variable Instantiations
***************************************************************************************************/

/***************************************************************************************************
                                          Function Bodies
***************************************************************************************************/

/***************************************Global (API) Functions*************************************/

void eWriteCS(uint8_t high)
{
  if(high)
  {
     gpoAPI -> Set(gpoCS);
  }
  else
  {
     gpoAPI -> Clear(gpoCS);
  }
}
void eWriteReset(uint8_t high)
{
  if(high)
  {
    gpoAPI -> Set(gpoReset);
  }
  else
  {
    gpoAPI -> Clear(gpoReset);
  }
}

uint8_t eGetReady(void)
{
   return gpiAPI->Get(gpiBusy);
}

void eWriteByte(uint8_t data)
{ 
    gpoAPI -> Set(gpoDC);
    gpoAPI -> Clear(gpoCS);
    spiAPI -> Write(&data,1);
    gpoAPI -> Set(gpoCS);
}


void ePaper_WriteCMD(uint8_t command)
{
    //Make sure the dsplay is not busy before starting a new command.
    while(0 == gpiAPI->Get(gpiBusy));
    //delay(500);
    //Select the controller   
    gpoAPI -> Clear(gpoCS);
    //Aim at the command register
    gpoAPI -> Clear(gpoDC);
    spiAPI -> Write(&command,1);
    //Deselect the controller
    gpoAPI -> Set(gpoCS);
}



void ePaper_Init(
                 SPI_Peripheral const spi,
                 GPO_Peripheral const cs,
                 GPO_Peripheral const dc,
                 GPO_Peripheral const rst,
                 GPI_Peripheral const busy
                )
{
    spiAPI = BSP_SPI_Init(spi);
    gpoAPI = BSP_GPO_Init(GPO_DISPLAY_DC);
    gpoAPI = BSP_GPO_Init(GPO_DISPLAY_CS);
    gpoAPI = BSP_GPO_Init(GPO_EINK_RST);
    gpiAPI = BSP_GPI_Init(GPI_EINK_BUSY);
    gpoCS  = cs;
    gpoDC  = dc;
    gpoReset = rst;
    gpiBusy = busy;

#if 0
    gpoAPI -> Clear(gpoReset);
    delay(2);
    gpoAPI -> Set(gpoReset);
    delay(2);

    WriteCMD_StringFlash(Power_Setting_PWR_On               , sizeof(Power_Setting_PWR_On               ) ) ;
    WriteCMD_StringFlash(Booster_Soft_Start_BTST            , sizeof(Booster_Soft_Start_BTST            ) ) ;
    WriteCMD_StringFlash(Power_ON_PON                       , sizeof(Power_ON_PON                       ) ) ;
    //WriteCMD_StringFlash(Panel_Setting_PSR                  , sizeof(Panel_Setting_PSR                  ) ) ;
    //WriteCMD_StringFlash(Vcom_and_data_interval_setting_CDI , sizeof(Vcom_and_data_interval_setting_CDI ) ) ;
    WriteCMD_StringFlash(PLL_control_PLL                    , sizeof(PLL_control_PLL                    ) ) ;
    WriteCMD_StringFlash(Resolution_setting_TRES            , sizeof(Resolution_setting_TRES            ) ) ;
    WriteCMD_StringFlash(VCM_DC_Setting_VDCS_On             , sizeof(VCM_DC_Setting_VDCS_On             ) ) ;
#else
    uint8_t bufferTest[5] = {'A', 'B', 'C', 'D', 'E'};
    gpoAPI -> Clear(gpoCS);
spiAPI->Write(bufferTest,5);
spiAPI->Write(bufferTest,5);
spiAPI->Write(bufferTest,5);
spiAPI->Write(bufferTest,5);
spiAPI->Write(bufferTest,5);
spiAPI->Write(bufferTest,5);
spiAPI->Write(bufferTest,5);
gpoAPI -> Set(gpoCS);

#endif
}

void ePaper_PowerOff(void)
{
    WriteCMD_StringFlash(Vcom_and_data_interval_setting_CDI_Off , sizeof(Vcom_and_data_interval_setting_CDI_Off ) ) ;
    WriteCMD_StringFlash(VCM_DC_Setting_VDCS_Off                , sizeof(VCM_DC_Setting_VDCS_Off                ) ) ;
    WriteCMD_StringFlash(Power_Setting_PWR_Off                  , sizeof(Power_Setting_PWR_Off                  ) ) ;
    WriteCMD_StringFlash(Power_OFF_POF                          , sizeof(Power_OFF_POF                          ) ) ;
    WriteCMD_StringFlash(Deep_sleep_DSLP                        , sizeof(Deep_sleep_DSLP                        ) ) ;
}

uint8_t reverse(uint8_t v)
{
  unsigned int r = v; // r will be reversed bits of v; first get LSB of v
  int s = sizeof(v) * 8 - 1; // extra shift needed at end

  for (v >>= 1; v; v >>= 1)
  {   
    r <<= 1;
    r |= v & 1;
    s--;
  }
  r <<= s; // shift when v's highest bits are zero
  return r;
}

void Load_Flash_Image_To_Display_RAM(uint16_t width_pixels, uint16_t height_pixels, const uint8_t *BW_image, const uint8_t *red_image)
{
    uint16_t index=0;

    //Get width_bytes from width_pixel, rounding up
    uint8_t width_bytes=(width_pixels+7)>>3;  

    //Make sure the display is not busy before starting a new command.
    while(0 == gpiAPI->Get(gpiBusy));
    //delay(500);
    //Select the controller   
    gpoAPI -> Clear(gpoCS);

    //Aim at the command register
    gpoAPI -> Clear(gpoDC);
    //Write the command: DATA START TRANSMISSION 1 (DTM1) (R10H)
    //  Display Start Transmission 1
    //  (DTM1, White/Black Data)
    //
    // This command starts transmitting data and write them into SRAM. To complete
    // data transmission, command DSP (Data transmission Stop) must be issued. Then
    // the chip will start to send data/VCOM for panel.
    //  * In B/W mode, this command writes “OLD” data to SRAM.
    //  * In B/W/Red mode, this command writes “B/W” data to SRAM.
    uint8_t data = 0x13;
    spiAPI -> Write(&data,1);
    //Pump out the BW data.
    gpoAPI -> Set(gpoDC);

    index=0;
    for(uint16_t y=0;y<height_pixels;y++)
    {
        for(uint8_t x=0;x<width_bytes;x++)
        {
            data = ~BW_image[index];
            spiAPI -> Write(&data,1);
            index++;
        }
    }

    //Aim back at the command register
    gpoAPI -> Clear(gpoDC);
    //Write the command: DATA STOP (DSP) (R11H)
   //display.spi->WriteByte(0x11);
    //Write the command: Display Refresh (DRF)   
    data = 0x12;
    spiAPI -> Write(&data, 1);
    //Deslect the controller   
    gpoAPI -> Set(gpoCS);
    while (0 == gpiAPI->Get(gpiBusy));
}

void Load_Inverse_Flash_Image_To_Display_RAM(uint16_t width_pixels, uint16_t height_pixels, const uint8_t *BW_image, const uint8_t *red_image)
{

}




/******************************************Private Functions***************************************/
void WriteCMD_StringFlash(const uint8_t *data, uint8_t datalen)
{
    
    uint8_t index = 0;

    //Make sure the display is not busy before starting a new command.
    while(0 == gpiAPI->Get(gpiBusy));
    //Select the controller   
    gpoAPI->Clear(gpoCS);
    //The first byte in the string is the command, aim at the command register
    gpoAPI->Clear(gpoDC);
    uint8_t data2 = data[index++];
    spiAPI -> Write(&data2,1);
    //Remember that we wrote the command that was in data[0]
    datalen--;

    //Remaining bytes are data, aim at the data register
    gpoAPI->Set(gpoDC);
    for(uint8_t i= 0;i<datalen;i++)
    {
        data2 = data[index++];
        spiAPI -> Write(&data2,1);
    }
    //Deslect the controller   
    gpoAPI->Set(gpoCS);
    
}



/* Millisecond Delay Function */
 void delay( const uint32_t delay_ms)
{
  uint32_t currentTime_ms = GetSysTickTimerValue()+delay_ms;
  while( (currentTime_ms) >= GetSysTickTimerValue());
}


/**********************************************************
 * Displays the current frame buffer on the EPD panel. 
 * This function will copy the current emWin frame buffer, 
 * power up the EPD panel, transmit the image and 
 * power down the panel again. It also saves the
 * frame in a separate buffer, since the old image
 * is used by the update process to get the best
 * possible contrast and minimal ghosting. 
 **********************************************************/
void showImage(void)
{
  #if (SMALL_SCREEN==1)
  /* Send the EPD frame to the COG */
  //Load_Flash_Image_To_Display_RAM(pannel_width,pannel_height, emwinFrameBuffer,emwinFrameBuffer);
  #else

    #if 1
      //Display the splash screen
      ePaper_WriteCMD(0x13);

      for (int i = 0; i < 15000; i++)
      {
          gpoAPI -> Set(gpoDC);
          gpoAPI -> Clear(gpoCS);
          uint8_t j = i%255;
          spiAPI -> Write(&j,1);
          gpoAPI -> Set(gpoCS);

      }
      //refresh the display
      ePaper_WriteCMD(0x12);
      while (0 == gpiAPI->Get(gpiBusy));
      #else
      //Display the splash screen
      //ePaper_WriteCMD(0x10);

      Load_Flash_Image_To_Display_RAM(pannel_width,pannel_height, emwinFrameBuffer,emwinFrameBuffer);

      //refresh the display
      //ePaper_WriteCMD(0x12);

      #endif
  #endif
}



//================================================================================
void setOTPLUT()
{
  //set panel setting to call LUTs from OTP
  ePaper_WriteCMD(0x00);
  eWriteByte(0x93);
}
void setPartialRegisterLUT()
{
  //set LUTs
  //The following block allows the LUTs to be changed.
  //In order for these LUTs to take effect, command 0x00 must have bit 5 set to "1"
  //set panel setting to call LUTs from the register
  ePaper_WriteCMD(0x00);
  eWriteByte(0x37); 

  //VCOM_LUT_LUTC
  ePaper_WriteCMD(0x20);
  for (int i = 0; i < 44; i++)
  {
    eWriteByte(VCOM_LUT_LUTC_PARTIAL[i]);
  }
  //W2W_LUT_LUTWW
  ePaper_WriteCMD(0x21);
  for (int i = 0; i < 42; i++)
  {
    eWriteByte(W2W_LUT_LUTWW_PARTIAL[i]);
  }
  //B2W_LUT_LUTBW_LUTR
  ePaper_WriteCMD(0x22);
  for (int i = 0; i < 42; i++)
  {
    eWriteByte(B2W_LUT_LUTBW_LUTR_PARTIAL[i]);
  }
  //W2B_LUT_LUTWB_LUTW
  ePaper_WriteCMD(0x23);
  for (int i = 0; i < 42; i++)
  {
    eWriteByte(W2B_LUT_LUTWB_LUTW_PARTIAL[i]);
  }
  //B2B_LUT_LUTBB_LUTB
  ePaper_WriteCMD(0x24);
  for (int i = 0; i < 42; i++)
  {
    eWriteByte(B2B_LUT_LUTBB_LUTB_PARTIAL[i]);
  }
}

void partialUpdateCharacters(const unsigned char holder[] )
{
  //setPartialRegisterLUT();

  //x1 must be divisible by 8
  uint16_t x1 = 200;
  uint16_t y1 = 0;
  uint16_t x2 = x1 + 61;
  uint16_t y2 = y1 + 99;

  //turn on partial update mode
  ePaper_WriteCMD(0x91);

  ePaper_WriteCMD(0x90);
  eWriteByte(x1 >> 8);   //1st half x
  eWriteByte(x1 & 0xf8); //2nd half x
  eWriteByte(x2 >> 8);   //1st half x
  eWriteByte((x2 & 0xf8) | 0x07);  //2nd half x
  eWriteByte(y1 >> 8);   //1st half w
  eWriteByte(y1 & 0xff); //2nd half w
  eWriteByte(y2 >> 8);   //1st half l
  eWriteByte(y2 & 0xff); //2nd half l
  eWriteByte(0x01);

  ePaper_WriteCMD(0x13);

  for (int h = 8*100; h >0 ; h--)
  {
      eWriteByte(reverse(holder[h]));
  }

  //partial refresh of the same area as the partial update
  ePaper_WriteCMD(0x12);
  while(0 ==gpiAPI->Get(gpiBusy));
  //Select the controller   
  //Turn off partial update mode
  ePaper_WriteCMD(0x92);
  //setOTPLUT();
  //setRegisterLUT();

}



long roundUp(long n, long m) {
    return n >= 0 ? ((n + m - 1) / m) * m : (n / m) * m;
}
void partialUpdate_DrawCharacter(const unsigned char holder[], uint16_t x, uint16_t y )
{
  //setPartialRegisterLUT();

  //x1 must be divisible by 8
  uint16_t x1 = roundUp(x,8);
  uint16_t y1 = roundUp(y,8);
  uint16_t x2 = x1 + 61;
  uint16_t y2 = y1 + 99;

  //turn on partial update mode
  ePaper_WriteCMD(0x91);

  ePaper_WriteCMD(0x90);
  eWriteByte(x1 >> 8);   //1st half x
  eWriteByte(x1 & 0xf8); //2nd half x
  eWriteByte(x2 >> 8);   //1st half x
  eWriteByte((x2 & 0xf8) | 0x07);  //2nd half x
  eWriteByte(y1 >> 8);   //1st half w
  eWriteByte(y1 & 0xff); //2nd half w
  eWriteByte(y2 >> 8);   //1st half l
  eWriteByte(y2 & 0xff); //2nd half l
  eWriteByte(0x01);

  ePaper_WriteCMD(0x13);

  for (int h = 8*100; h >0 ; h--)
  {
      eWriteByte(reverse(holder[h]));
  }

  //partial refresh of the same area as the partial update
  ePaper_WriteCMD(0x12);
  while(0 == gpiAPI->Get(gpiBusy));
  //Select the controller   
  //Turn off partial update mode
  ePaper_WriteCMD(0x92);
  //setOTPLUT();
  //setRegisterLUT();

}





const unsigned char Mono_Letter_C[464]  =
  {0xFF,0xFF,0xFF,0xF0,0x07,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0x80,0x00,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFE,0x00,0x00,0x3F,0xFF,0xFF,
   0xFF,0xF9,0xF0,0x03,0xF0,0x0F,0xFF,0xFF,
   0xFF,0xDC,0x00,0x1F,0xFC,0x07,0xFF,0xFF,
   0xFF,0xDC,0x00,0x3F,0xFF,0x03,0xFF,0xFF,
   0xFF,0xEE,0x00,0x78,0x1F,0x81,0xFF,0xFF,
   0xFF,0xE6,0x00,0xE7,0xE7,0xC0,0xFF,0xFF,
   0xFF,0xF7,0x01,0x9F,0xF3,0xC0,0x7F,0xFF,
   0xFF,0xF3,0x01,0x7F,0xFD,0xE0,0x3F,0xFF,
   0xFF,0xFB,0x83,0xFF,0xFC,0xE0,0x3F,0xFF,
   0xFF,0xFD,0x83,0xFF,0xFE,0xF0,0x1F,0xFF,
   0xFF,0xFD,0xC7,0xFF,0xFF,0x70,0x0F,0xFF,
   0xFF,0xFE,0xC7,0xFF,0xFF,0x70,0x0F,0xFF,
   0xFF,0xFE,0xE7,0xFF,0xFF,0x38,0x07,0xFF,
   0xFF,0xFF,0x67,0xFF,0xFF,0xB8,0x07,0xFF,
   0xFF,0xFF,0x7F,0xFF,0xFF,0xB8,0x07,0xFF,
   0xFF,0xFF,0xBF,0xFF,0xFF,0xB8,0x03,0xFF,
   0xFF,0xFF,0xBF,0xFF,0xFF,0xB8,0x03,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x03,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x03,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x01,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xDC,0x03,0xFF,
   0xFF,0xFF,0x3F,0xFF,0xFF,0xB8,0x03,0xFF,
   0xFF,0xFE,0x3F,0xFF,0xFF,0xB8,0x03,0xFF,
   0xFF,0xEE,0x3F,0xFF,0xFF,0xB8,0x03,0xFF,
   0xFF,0xE6,0x3F,0xFF,0xFF,0xB8,0x03,0xFF,
   0xFF,0xE6,0x3F,0xFF,0xFF,0x70,0x07,0xFF,
   0xFF,0xF6,0x1F,0xFF,0xFF,0x70,0x07,0xFF,
   0xFF,0xF6,0x1F,0xFF,0xFF,0x70,0x0F,0xFF,
   0xFF,0xF7,0x1F,0xFF,0xFE,0xE0,0x0F,0xFF,
   0xFF,0xF7,0x1F,0xFF,0xFE,0xE0,0x0F,0xFF,
   0xFF,0xF3,0x0F,0xFF,0xFD,0xC0,0x1F,0xFF,
   0xFF,0xFB,0x8F,0xFF,0xFD,0xC0,0x3F,0xFF,
   0xFF,0xFB,0x87,0xFF,0xFB,0x80,0x3F,0xFF,
   0xFF,0xF9,0x83,0xFF,0xF7,0x80,0x7F,0xFF,
   0xFF,0xFD,0xC3,0xFF,0xEF,0x00,0xFF,0xFF,
   0xFF,0xFC,0xE1,0xFF,0xDC,0x01,0xFF,0xFF,
   0xFF,0xFE,0x70,0x7F,0xF8,0x03,0xFF,0xFF,
   0xFF,0xFF,0x78,0x1F,0xE0,0x07,0xFF,0xFF,
   0xFF,0xFF,0xBC,0x00,0x00,0x1F,0xFF,0xFF,
   0xFF,0xFF,0xCF,0x00,0x00,0x7F,0xFF,0xFF,
   0xFF,0xFF,0xE7,0xE0,0x07,0xDF,0xFF,0xFF,
   0xFF,0xFF,0xF1,0xFF,0xFF,0x7F,0xFF,0xFF,
   0xFF,0xFF,0xFC,0x3F,0xF1,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xC0,0x0F,0xFF,0xFF,0xFF};

const unsigned char Mono_Letter_F[464]  =
  {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xF0,0x00,0x00,0x00,0x00,0x07,0xFF,
   0xFF,0xF8,0x00,0x00,0x00,0x00,0x0F,0xFF,
   0xFF,0x3C,0x00,0x00,0x00,0x00,0x1F,0xFF,
   0xFF,0xBC,0x00,0x3F,0xFF,0x00,0x7F,0xFF,
   0xFF,0xDE,0x00,0xFF,0xFF,0x00,0xFF,0xFF,
   0xFF,0xEF,0x03,0xC0,0x07,0x00,0xFF,0xFF,
   0xFF,0xE7,0x06,0x7F,0xF7,0x00,0xFF,0xFF,
   0xFF,0xF7,0x85,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFB,0x8F,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xF9,0x9F,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFD,0xDF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFD,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFE,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFE,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFE,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0x7F,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFB,0x7F,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFB,0x3F,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFB,0x1F,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFB,0x0F,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFB,0x07,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFB,0x03,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFB,0x00,0x00,0x00,0x1F,0xFF,
   0xFF,0xFF,0xFB,0x00,0x00,0x00,0x07,0xFF,
   0xFF,0xFF,0xFB,0x00,0x00,0x00,0x03,0xFF,
   0xFF,0xFF,0xFB,0x03,0xFF,0x00,0xF1,0xFF,
   0xFF,0xFF,0xFB,0x07,0xFF,0x00,0xFC,0xFF,
   0xFF,0xFF,0xFB,0x0F,0xFF,0x00,0x1E,0xFF,
   0xFF,0xFF,0xFB,0x10,0x07,0x00,0xE7,0xFF,
   0xFF,0xFF,0xFB,0x3F,0xF7,0x00,0xF3,0xFF,
   0xFF,0xFF,0xFB,0x7F,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFB,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFB,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFB,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF6,0x00,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xEC,0x00,0x3F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xC8,0x00,0x0F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0x90,0x00,0x07,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xA0,0x00,0x03,0xFF,
   0xFF,0xFF,0xFF,0xFF,0x7F,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFC,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x07,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

const unsigned char Mono_Letter_A[464]  =
  {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0x80,0x00,0x1F,0xFF,0xFF,
   0xFF,0xFF,0xFD,0xC0,0x00,0x3F,0xFF,0xFF,
   0xFF,0xFF,0xFE,0xE0,0x00,0x7F,0xFF,0xFF,
   0xFF,0xFF,0xFF,0x70,0x00,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xB8,0x01,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0x98,0x00,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xB0,0x00,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xB0,0x00,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0x30,0x08,0x7F,0xFF,0xFF,
   0xFF,0xFF,0xFF,0x60,0x08,0x7F,0xFF,0xFF,
   0xFF,0xFF,0xFF,0x60,0x0C,0x7F,0xFF,0xFF,
   0xFF,0xFF,0xFE,0xC0,0x0C,0x3F,0xFF,0xFF,
   0xFF,0xFF,0xFE,0xC0,0x0C,0x3F,0xFF,0xFF,
   0xFF,0xFF,0xFC,0xC0,0x2E,0x1F,0xFF,0xFF,
   0xFF,0xFF,0xFD,0x80,0x36,0x1F,0xFF,0xFF,
   0xFF,0xFF,0xFD,0x80,0x37,0x1F,0xFF,0xFF,
   0xFF,0xFF,0xFB,0x00,0x73,0x0F,0x7F,0xFF,
   0xFF,0xFF,0x7B,0x00,0x7B,0x0C,0xFF,0xFF,
   0xFF,0xFF,0x33,0x00,0x7B,0x81,0xDF,0xFF,
   0xFF,0xFB,0x16,0x00,0xFD,0x83,0x9F,0xFF,
   0xFF,0xF6,0x06,0x00,0xFD,0x87,0x0F,0xFF,
   0xFF,0xF6,0x00,0x01,0xFC,0xC2,0x0F,0xFF,
   0xFF,0xF6,0x00,0x01,0xFE,0xC0,0x07,0xFF,
   0xFF,0xEC,0x00,0x01,0xFE,0xE0,0x07,0xFF,
   0xFF,0xEC,0x00,0x03,0xFE,0x60,0x03,0xFF,
   0xFF,0xD8,0x00,0x03,0xFC,0xC0,0x1F,0xFF,
   0xFF,0xDF,0xF0,0x03,0xF9,0x80,0x7F,0xFF,
   0xFF,0xBF,0xF0,0x07,0xF3,0x80,0xFF,0xFF,
   0xFF,0x80,0x30,0x03,0xF7,0x00,0xFF,0xFF,
   0xFF,0xFF,0x20,0x01,0xEE,0x00,0x7F,0xFF,
   0xFF,0xFF,0x60,0x00,0xDC,0x08,0x7F,0xFF,
   0xFF,0xFF,0x60,0x00,0x58,0x18,0x7F,0xFF,
   0xFF,0xFE,0xC0,0x10,0x38,0x1C,0x3F,0xFF,
   0xFF,0xFE,0xC0,0x18,0x10,0x6C,0x3F,0xFF,
   0xFF,0xFE,0xC0,0x1C,0x00,0xEC,0x3F,0xFF,
   0xFF,0xFD,0x80,0x2E,0x00,0xEC,0x1F,0xFF,
   0xFF,0xFD,0x80,0x37,0x01,0xF6,0x1F,0xFF,
   0xFF,0xF9,0x80,0x3B,0x83,0xF6,0x0F,0xFF,
   0xFF,0xFB,0x00,0x7D,0x83,0xF6,0x0F,0xFF,
   0xFF,0xFB,0x00,0x7D,0xC7,0xF7,0x0F,0xFF,
   0xFF,0xF7,0x00,0xFE,0xEF,0xFB,0x07,0xFF,
   0xFF,0xF6,0x00,0xFF,0x6F,0xFB,0x07,0xFF,
   0xFF,0xF6,0x00,0xFF,0x3F,0xFB,0x03,0xFF,
   0xFF,0xEC,0x01,0xFF,0xBF,0xFB,0x01,0xFF,
   0xFF,0xEC,0x01,0xFF,0xFF,0xFB,0x01,0xFF,
   0xFF,0xCC,0x01,0xFF,0xFF,0xFB,0x00,0xFF,
   0xFF,0xD8,0x03,0xFF,0xFF,0xFB,0x00,0x7F,
   0xFF,0x98,0x03,0xFF,0xFF,0xF6,0x00,0x3F,
   0xFF,0x20,0x01,0xFF,0xFF,0xF4,0x00,0x1F,
   0xFE,0x40,0x00,0x7F,0xFF,0xEC,0x00,0x0F,
   0xFC,0x80,0x00,0x3F,0xFF,0xE8,0x00,0x03,
   0xFB,0x00,0x00,0x1F,0xFF,0xD0,0x00,0x01,
   0xF7,0xFF,0xFF,0xFF,0xFF,0xBF,0xFF,0xFF,
   0xEF,0xFF,0xFF,0xFF,0xFF,0x3F,0xFF,0xFF,
   0x80,0x00,0x00,0x7F,0xFF,0x00,0x00,0x07,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

const unsigned char Mono_Letter_P[464]  =
  {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x07,0xFF,
   0xFF,0xFF,0xFF,0x00,0x00,0x00,0x0F,0xFF,
   0xFF,0xFF,0xF8,0x00,0x00,0x00,0x1F,0xFF,
   0xFF,0xFF,0xE0,0x01,0xFF,0x80,0x3F,0xFF,
   0xFF,0xFF,0xC0,0x0F,0xFF,0x80,0x7F,0xFF,
   0xFF,0xFF,0x80,0x3F,0xFF,0x80,0x7F,0xFF,
   0xFF,0xFB,0x00,0x78,0x01,0x80,0x7F,0xFF,
   0xFF,0xF7,0x00,0x4F,0xFD,0x80,0x7F,0xFF,
   0xFF,0xEE,0x00,0xBF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xEE,0x00,0x7F,0xFD,0x80,0x7F,0xFF,
   0xFF,0xEC,0x01,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xDC,0x01,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xDC,0x01,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xDC,0x01,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xDC,0x01,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xDC,0x01,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xDC,0x01,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xDC,0x00,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xDE,0x00,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xCE,0x00,0x7F,0xFD,0x80,0x7F,0xFF,
   0xFF,0xEF,0x00,0x7F,0xFD,0x80,0x7F,0xFF,
   0xFF,0xEF,0x80,0x1F,0xFD,0x80,0x7F,0xFF,
   0xFF,0xE7,0xC0,0x0F,0xFD,0x80,0x7F,0xFF,
   0xFF,0xF7,0xE0,0x00,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFB,0xF0,0x00,0x00,0x00,0x07,0xFF,
   0xFF,0xFD,0xFE,0x00,0x00,0x00,0x01,0xFF,
   0xFF,0xFE,0xFF,0xE0,0x00,0x00,0x00,0xFF,
   0xFF,0xFF,0x3F,0xFF,0xFF,0x80,0x7C,0x7F,
   0xFF,0xFF,0xCF,0xFF,0xFF,0x80,0x7F,0x3F,
   0xFF,0xFF,0xF0,0x7F,0xFD,0x80,0x07,0xFF,
   0xFF,0xFF,0xFF,0x80,0x01,0x80,0x79,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFD,0x80,0x7F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF9,0x00,0x1F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xF2,0x00,0x0F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xE4,0x00,0x07,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xE8,0x00,0x03,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xDF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xBF,0xFF,0xFF,0xFF,
   0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0F,0xFF,
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
/***************************************************************************************************
                                            End of file
***************************************************************************************************/